06.09.2010 imo
Renamed org.eclipse.scout.rt.ui.swing.ext.calendar.JTimeChooser to org.eclipse.scout.rt.ui.swing.ext.calendar.TimeChooser
Renamed org.eclipse.scout.rt.ui.swing.ext.calendar.JCalendar to org.eclipse.scout.rt.ui.swing.ext.calendar.DateChooser
Migration (occurs only in rare cases): Rename *.java files

15.12.2010 imo
Refactored the date time fields in order to use two fields when entering date and time.
Migration: None

15.12.2010 imo
Changed fields with dropdownbutton to single field with integrated drop down button
Migration: None

24.01.2011 dwi
Ticket 95'946
Visual markup for editable cells
Migration: None

27.01.2011 dwi
Problem:
In SwingScoutTable#prepareRenderer, evaluation of cell's editable state to draw respective marker icon caused loops and UI freeze.
So far, the only way to determine cell's editable state was to call AbstractColumn#isCellEditable(ITableRow). This required synchronization with model thread which affected performance badly. Even worse, if model thread was busy, the enqueued request did not succeed at all (timeout).
Solution:
- Property added to hold result of AbstractColumn#isCellEditable(ITableRow) which can be evaluated in UI thread without need of model thread synchronization.
- Population of property: Property is populated when AbstractColumn#decorateCellInternal is called.
- Change of ICellSpecialization and implementing classes: added ICellSpecialization$isEditable(), added ICellSpecialization#setEditable(boolean)
- Change of ICell and implementing classes: added ICell#isEditable()) -> default value is false
- Change of Cell: added Cell#isEditable(), added Cell#setEditableInternal(boolean). Accessor setEditableInternal(boolean) is internal by intention as not intended for public use as various checks in AbstractColumn#execIsEditable are bypassed otherwise (JavaDoc added). E.g., do not use in execDecorateCell.
- Change of SwingTableModel#isCellEditable() --> synchronization with model thread not neccessary anymore as property can be evaluated thread safe. (Java bean property)
- Change of SwingScoutTable#prepareRenderer() --> synchronization with model thread for querying editable state not neccessary anymore as property can be evaluated thread safe. (Java bean property)
Migration: None

11.03.2011 bsh
- ColorUtility: Added a method to "multiply" two colors (instead of merging them). See JavaDoc for details.
- ColorUtility: All methods are now null-safe.
- SwingScoutTable: Fixed calculation of resulting foreground and background color when a row is selected (merge -> multiply).
Migration: None

17.3. 2011
fix for bsi ticket #98515
Migration: None

03.05.2011 dwi
fixed ticket #92911
Problem: Fixed that LABEL_POSITION_ON_FIELD has no effect on multiline string fields
Migration: None

17.05.2011 imo
bsi ticket 102'175, contributed by Beat Schwarzentrub BSI AG
When a user double-clicks on a row in a TablePage, the tree is automatically expanded, the corresponding node is selected, and the tree is scrolled, such that the selected node and as many as possible of its sub nodes are visible.
This behaviour is confusing when browsing trees with nodes that have long labels. The current implementation tries to move as much as possible of the target nodes rectangle to the visible area. For nodes that are on deeper levels, this means, that the tree is scrolled horizontally and the node is drawn on the left side of the tree border (Figures 1, 2). When the user wants to get back to the parent node, it might not be recognizable anymore.
The same applies, when getConfiguredScrollToSelection() is true, or the method scrollToSelection() is called manually.
The tree should only automatically scroll horizontally when the node would be completely off the right side of the tree's border. To prevent the tree from "jumping" too much around, only a small part of the node's label should be guaranteed to be drawn. The proposed patch (currently only for Swing, there might be better approaches...) uses a maximum of 30 pixels or 25% of the node's width. The result is more like what the user would expect.
Change: as proposer
Migration: None
