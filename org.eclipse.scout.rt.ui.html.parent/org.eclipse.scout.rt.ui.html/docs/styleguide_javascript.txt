+---------------------------------+
| BSI JavaScript Style Guide      |
+---------------------------------+

Als Basis dient der Google JavaScript StyleGuide:
https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml
Bei einigen Punkten wurde auch der StyleGuide von jQuery zu Rate gezogen:
http://contribute.jquery.org/style-guide/js/


### Variablen

- Variablen wenn moeglich immer am Anfang der Funktion deklarieren. Variablen am
  Anfang zu Deklarieren ist good practice, denn die JS-Engine macht das bei der
  Ausfuehrung sowieso(variable hoisting).
- Pro 'var' Anweisung dürfen mehrere Variablen deklariert und auch initialisiert
  werden. Komplexe Initialisierung soll aber auf einer separaten Zeile notiert
  werden.
- Grundsätzlich ist eine kompakte Darstellung erwünscht, die Lesbarkeit soll
  aber nicht darunter leiden.


Beispiele:

NOK:                           OK:
-------------------------------------------------------------------------
var x = (y > 0 ? 1 : 2), y = $('h1').children('.myClass').first().text();

                               var x, y = 3;

                               var x = 4,
                                 y = 3,
                                 value = $('h1').text();

Links:
- http://benalman.com/news/2012/05/multiple-var-statements-javascript/


### Visibility
Wir verwenden _ als Prefix für private Members einer Klasse. Solche Members dürfen von aussen nicht zugegriffen werden (Ausnahme: in Tests/Specs)


### Pruefen, ob eine Variable oder ein Property existiert

        +-------------------------------------+----------------------------------+
        | FUER PROPERTIES:                    | FUER VARIABLEN:                  |
 +------+-------------------------------------+----------------------------------+
 | #1   | if (obj.x === undefined)            | if (y === undefined)             |
 |      |                                     |                                  |
 | #2   | if (typeof obj.x === 'undefined')   | if (typeof y === 'undefined')    |
 |      |                                     |                                  |
 | #3   | if (obj.hasOwnProperty('x'))        | -                                |
 +------+-------------------------------------+----------------------------------+

Bewertung:
- #1 funktioniert bei Properties, aber nicht bei Variablen. Wenn die Variable nicht
  definiert ist, gibt es eine Exception. Weiteres (theoretisches) Problem: Jemand
  koennte die Variable 'undefined' umdefinieren. (wir stellen jedoch im scout-module.js
  sicher, dass dies nicht geschehen kann).
- #2 funktioniert immer. Bei Properties werden auch diejenigen der Protoypen
  beruecksichtigt.
- #3 kann sinnvoll sein, denn es schaut _nicht_ beim Prototyp nach. Allerdings scheint
  es extrem langsam zu sein, darum besser nicht verwenden.

--> Wir verwenden grundsätzlich Variante #1. Exceptions die durch nicht deklarierte
    Variablen verursacht werden sind Programmierfehler.

Links:
- http://stackoverflow.com/questions/4725603
- http://stackoverflow.com/questions/17150396
- http://jsperf.com/hasownproperty-vs-in/2


### Gleichheit pruefen

Empfehlung: Immer === verwenden, es sei denn, man moechte explizit Type Coercion
verwenden bzw. unterstuetzen. Ansonsten ist es besser, dass der Code auch mit dem
strikten Vergleich funktioniert (und nicht nur "zufaellig" wegen JS-Type-Magie).

Performance scheint nur eine untergeordnete Rolle zu spielen:
http://www.adequatelygood.com/Performance-of-vs-.html


### Exceptions werfen

Man kann in JS grundsaetzlich beliebige Objekte werfen. Es sollte aber immer ein Error-
Objekt geworfen werden, nie nur ein String. Das Problem mit Strings ist, dass nicht
alle "Faenger" damit umgehen konnen. Jasmine z.B. zeigt dann nur "undefined: undefined"
als Meldung an, was ueberhaupt nicht hilfreich ist. IE hat angeblich auch Probleme damit.
FireFox zeigt keine Line-Number-Info an ohne Error Object.

NOK:                           OK:
-------------------------------------------------------------------------
throw 'This is an error';      throw new Error('This is an error');

Links:
http://www.nczonline.net/blog/2009/03/10/the-art-of-throwing-javascript-errors-part-2/
http://stackoverflow.com/questions/11502052/throwing-strings-instead-of-errors


### Strings

In JavaScript fuer Strings immer einheitlich ' als Begrenzer verwenden.

Ausnahme: Wenn innerhalb des Strings sehr viele Apostrophe vorkommen, kann man die
Anfuehrungszeichen umkehren, damit man sich das Escapen sparen kann.

Und: In einem JSON-Objekt _muessen_ fuer Strings " verwendet werden! Aber Achtung, wenn man
ein JS-Objekt im Code von Hand erzeugt, dann ist noch lange kein JSON! Trotzdem kann man da,
wenn man moechte, doppelte Anfuehrungszeichen verwenden.

Es gibt keinen wirklich triftigen Grund, ausser dass es besser ist, wenn nicht im ganzen
Code beide Arten von Anfuehrungszeichen durcheinander verwendet werden. Fuer das Erzeugen
von HTML-Code mit Attributen ist es ausserdem praktisch, wenn die doppelten
Anfuehrungszeichen nicht escaped werden muessen.

Beispiele:
var x = 'This is a string.';
var y = '<div id="' + model.id + '" class="row selected">That\'s it!</div>';
var z = "That's it!";
var obj = {
  "id": 123;
  'name': 'simple object';
};
var jsonResponse = '{ "id": 123, "name": "simple object" }';


### Kommentare

Kommentare immer so:
  // My comment

So nicht:
  //My comment
  /* My comment */


### Overloading

JavaScript kennt kein Ueberladen von Methoden. Allerdings sind Funktionen auch nicht streng
typisiert, somit kann eine dynamische Anzahl Argumente uebergeben werden, mit unterschiedlichen
Typen. Ein Pattern um Overloading zu implementieren ist wie folgt. Agenommen die Methode 'setSize'
soll mit 2 Numbers und mit einem Dimension Objekt aufgerufen werden koennen:

  obj.setSize(6, 7);

  obj.setSize(new Dimension(6, 7));

Die Implementierung von setSize ist wie folgt:

  setSize = function(vararg, height) {
    if (vararg instanceof Dimension) {
      this.width = vararg.width;
      this.height = vararg.height;
    } else {
      this.width = vararg;
      this.height = height;
    }
  };

Bei Konstruktoren moechte man oft auch einen Default-Konstruktor, das Beispiel oben liesse sich
dann wie folgt erweitern:

  this.width = vararg || 0;
  this.height = height || 0;

Für Konstruktoren mit vielen Parametern bietet es sich an, ein einzelnes Objekt als Parameter zu
verwenden. Wir nennen dieses Objekt "options". Dies macht die Erzeugung eines Objektes einiges
übersichtlicher:

  scout.MyObject = function(options) {
    options = options || {};
    var param1 = options.param1 || 'default';
    var param2 = options.param2 !== undefined ? options.param2 : true
  }

  var obj = new scout.MyObject({
    param1: 'abc',
    param2: false
  }

Achtung: Falls '', 0 oder false als Werte erlaubt sind, kann || nicht verwendet werden.
In diesen Faellen die ? Notation verwenden. Alternativ kann auch $.extend eingesetzt werden.


### Properties

Wir erzeugen keine Getter und Setter für einfache Properties (ohne Logik). Man soll direkt auf die
Variable zugreifen. Hauptgrund: Code wird nicht unnötig aufgeblasen.
Wenn der Getter/Setter Logik enthalten soll, dann erstellt man eine Methode aber ohne get/set.
Es ist ein Setter, wenn es ein Argument hat.
Beispiel:
  $.fn.cssMarginLeft = function(value) {
    if (value !== undefined) {
      return this.css('margin-left', value + 'px');
    }
    return $.pxToNumber(this.css('margin-left'));
  };

### Methoden mit jQuery-Objekten als Return-Werte

Wenn eine Methode ein jQuery-Objekt zurückgibt, soll dies im Namen ersichtlich sein.
z.B. var $selectedRows =  table.$selectedRows();


### Einzeilige if-Statements / Geschweifte Klammern

Bei 'if' soll die Bedingung immer auf einer separaten Zeile. Die einzelnen Klauseln sollen immer
in geschweifte Klammern eingefasst sein.

NOK:
  if (hasPrev && hasNext) $(this).addClass('select-middle');
OK:
  if (hasPrev && hasNext) {
    $(this).addClass('select-middle');
  }

Begruendung:
- Code wird robuster gegenueber unbeabsichtigt geaendertem Verhalten bei Refactorings.
- Wir machen es im Java-Code auch so.


### Method Chaining

Wenn eine Anweisung mit durch '.' verbundenen Methodenaufrufen auf mehrere Zeilen verteilt
werden soll, dann sollen die Punkte immer am Anfang der naechsten Zeile stehen.

  OK:                                      NOK:
  ----------------------------             -----------------------------
  $("#p1").css("color", "red")             $("#p1").css("color", "red").
    .slideUp(2000)                           slideUp(2000).
    .slideDown(2000);                        slideDown(2000);

Begruendung:
- Die Style-Guides sind sich nicht einig. Google macht die Punkte hinten, jQuery hingegen vorne.
  Da wir viele jQuery-Funktionen verwenden, halten wir uns an den jQuery-Styleguide.
- Der JS-Formatter in Eclipse beherrscht aktuell nur die Punkte vorne. Deshalb verwenden wir
  diesen Stil, obwohl er anders ist als im Java-Code.
