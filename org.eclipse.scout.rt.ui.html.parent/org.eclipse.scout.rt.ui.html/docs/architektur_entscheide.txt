JsonAdapter / JavaScript Model [03.06.2014 cgu, awe]
- Der Konstruktor aller JS ModelAdapter ist parameterlos. Grund: durch die JS-Vererbung via inheritsFrom, wird der super-Ctor
  immer einmal ohne Argumente aufgerufen, man müsste darum im Ctor 'if (model && session)' verwenden um Exceptions zu vermeiden.
  Darum wird neu anstatt dem Ctor eine init Methode mit den beiden Argumenten model, session verwendet.
- Server-seitig schicken wir nur beim ersten Mal das komplette Model als JSON-string. Der Client erzeugt aus diesem JSON-string
  eine ModelAdapter Instanz und speichert diese in der modelAdapterRegistry. Wird die gleiche Instanz ein zweites Mal benötigt, schickt
  der Server nur noch die ID dieser Instanz im JSON-string, der Client liefert dann die bereits vorhandene Instanz aus der model-
  AdapterRegistry zurück.
- Wird eine (Scout-)Model Instanz abgeräumt (z.B. eine Form Instanz) muss die serverseitige JsonAdapter Implementierung dafür sorgen,
  dass alle Kinder (z.B. FormFields) aus der modelAdapterRegistry entfernt werden. Der genau gleiche Clean-up muss auf Clientseite
  erfolgen und alle ModelAdapter Instanzen bzw. DOM Objekte aus der modelAdapterRegistry gelöscht werden (ModelAdapter.destroy())
- PROBLEME:
  - UseCase: Modell wird initial per Property Change geschickt (z.B. TableField.setTable(X)). Noch während der Server am drehen ist, wechselt die Table von X auf Y. Table X wird nun NIE geschickt, im Server ist sie aber in der Registry vorhanden.
    Passiert in der Widgets App wenn man auf Page & Search Forms, Page with nodes und dann Page with table klickt (Exception auf Client bei Menus)
  - UseCase2: Modell wird initial als Property geschickt (z.B: Form.RootGroupBox). Noch während der Server am drehen ist, gibt es Property-Change-Events auf die RootGroupBox. Diese PropertyChange Events müssten eigentlich nicht separat, sondern könnten als Teil des initialen Loads geschickt werden -> Spart Datenübertragung.
    Problem ist, dass man nicht weiss, welche Properties solche initialen Loads beinhalten.
    Passiert in der Widget APP z.B. in der ButtonsForm (Buttons werden erst nacht dem Laden dekoriert).
  Lösung? Alle Create Events vorher schicken? Beispiel: Page schickt DetailForm. DetailForm ist neu, gibt ein CreateEvent. FormFields darauf sind auch neu -> Create events.
  Auf dem Client müssten alle Create events zuerst behandelt werden, eigentlich auch in umgekehrter Reihenfolge. FormField zuerst erstellen, da Form sonst nicht initialisiert werden kann. Könnte aber trotzdem noch Abhängigkeitsprobleme geben.
  Eventuell alle erstellen und danach alle initialisieren?
  Parent/Child Abhängigkeit müsste bei der Initialisierung gesetzt werden.
  -> LÖSUNG: Server merkt sich modelAdapter und macht nicht direkt toJson. Er ignoriert dann alle Property-Change-Events für Objekte, die noch nicht an den Client geschickt wurden.
  JsonAdapter implementiert das Interface toJsonString, welches toJson().toString() macht.
  Insert und DeleteRows könnten auch ignoriert werden. Dann müsste es aber auch ein coalesce für selection event geben. UseCase: insert 5. select 5. Delete 5 -> 5 wird nicht geschickt, exception.
  Auf dem Client braucht es auch ein coalesce für Offline-Fall. Wenn auf einer Tabelle rumgeklickt wird, müssen nicht alle Selection-Events geschickt werden, sondern nur der letzte.
  TODO: Prüfen ob Parent/Child-Abhängigkeit überhaupt "verhebt". Beispiel: Menus, einmal als ContextMenü und einmal als Action-Bar. 2 GUIS mit einem Model.

ModelAdapter Property Changes
- Bei einem property change event werden die Werte der Properties auf den ModelAdapter übertragen. Danach werden die setter aufgerufen (z.B. setEnabled()).
- Im Setter wird der Status gerendert werden
- Manchmal muss jedoch im Setter auch der Property-Wert gesetzt werden, da der Server nicht mit einem property change event antwortet, wenn der Wert dem Client bereits bekannt ist (siehe PropertyFilter).
  Betrifft z.B. Checkbox.setSelected(). Oder auch StringField.setDisplayText.
  An anderen Orten möchte man aber explizit den Model-State nicht verändern, sondern nur das GUI. Z.B. goOffline/goOnline, damit man später das GUI auf den alten State zurücksetzen kann.
  Lösung? Eventuell die setter in render umbenennen und den Model-State strikt ausserhalb setzen (z.B. im Checkbox Klick-Listener.
- Weiterer offener Punkt: Die Render-Methoden dürfen eigentlich nur aufgerufen werden, wenn der Adapter dargestellt ist (isRendered). Ansonsten knallt es.
  Lösung? Gar nicht erst aufrufen, in der Methode auf isRendered prüfen. Oder sogar model von GUI trennen wie im Scout-Client?

Aufteilung zwischen GUI-Elementen und Server / Model-Interaktion?
- z.B. Table schickt Server Event im Selektions-Code. Alternative wäre ein Listener, welcher auf Selektion hört und dort den Event schickt.
- Vorteil des Listeners: Saubere Trennung, Komponenten könnten einfacher ersetzt werden?
- Nachteil: Eventuell unnötiger Zusatzaufwand

Offline
- 2 Use Cases: Tunnel und Aktenkoffer
- Tunnel:
  Applikation soll bedienbar bleiben, auch wenn temporär kein Netz da ist. Die Elemente werden readonly, ausser vielleicht Textfelder, damit der Benutzer weiter tippen kann.
  Baum, Tabelle, TableControls sollen weiterhin bedienbar sein. PROBLEM: Page-DetailForms müssten auf dem GUI als solche erkannt werden, damit sie ein/ausgeblendet werden können.
    -> Die DetailForms (und SearchForms) dürfen nicht auf den Desktop gelegt werden (mittels addForm) aus dem Model, das GUI soll sich darum kümmern. siehe auch FIXME in MiniCrmOutline
  Benutzer sieht, dass zur Zeit keine Verbindung hergestellt ist. Die Seite versucht automatisch, die Verbindung wieder herzustellen.
  Die Events werden aufgeonmmen und sobald der Server wieder erreichbar ist abgeschickt.
- Aktenkoffer:
  Der Benutzer kann Objekte auswählen, die Offline verfübar sein sollen.
  Werden dann alle Childpages auch geladen? Inkl. Aller Forms? ev. mittels Benutzer-Auswahl?
  Die Objekte werden in einer Offline-Sicht dargestellt.
  Die Offline-Sicht ist ähnlich zur Such-Sicht.
  Bearbeitung im Offline-Modus: 2-Varianten:
  1. Normale Scout-Komponenten so bearbeitbar wie möglich machen, Validierungen würden erst "zu Hause" (Online) durchgeführt.
     Viele Komponenten gingen gar nicht (z.B. Adressen, da die Selektions-Logik im Modell liegt).
     Auch dynamische Properties (visible, enabled). Alle Buttons und Menus. Es müsste UseCase-Buttons geben (z.B. neuer Eintrag in Tabelle hinzufügen). Man wäre dann aber sehr schnell wieder an der Grenze des Machbaren angelangt.
     Stammdaten für Smartfields könnte man cachen, Lookup-Call-Smartfields könnten aber bereits nicht mehr genutzt werden.
     Um überhaupt einen Dialog im Bearbeitungs-Modus öffnen zu können, braucht es intelligente Menüs bzw. Readonly und Bearbeitungs-Modus eines 360°-Dialogs, da im Offline-Fall die Menus grundsätzlich nicht funktionieren können.
     Dialog wäre gesperrt bei Mitnahme? Ansonsten würde es ja beim Zurücksynchronisieren einfach überschreiben.
     Ok, Abbrechen-Button müssten enabled sein. Dialog wird einfach geschlossen? Sobald online, wird ein doOk gemacht? Wie weiss man, dass OK-Button enabled sein soll?
     Alternative: Ok immer disabled, Dialog muss minimiert werden. Manuell Dialoge durchgehen und OK klicken sobald man zurück ist. Ansonsten müsste noch geklärt werden, wie Zurücksynchronisierung ablaufen soll.
     Oder Ansicht aller Offline-Dialoge analog Taskbar. Beim Synchronisieren nacheinander öffnen und speichern.
     Klick auf OK macht keine Mussfeldprüfung? Theoretisch eigentlich möglich, jedoch halt nicht für dynamische Dinge (eher selten). Eigentlich wäre es nicht schlecht, wenn es macht was es kann und den Rest am Schluss beim online gehen. Vielleicht sollte man einen Hinweis einblenden, dass beim Synchronisieren nochmals eine Überprüfung stattfindet.
  2. Man erstellt die Dialoge spezifisch für Offline
     Im Modell oder als Javascript-Komponenten? Falls im Modell, hätte man die selben Einschränkungen wie oben -> eher nicht.
     Falls als JS-Komonenten: Die bestehenden Komponenten (Table, SmartField etc.) sollten wiederverwendbar sein.
     Wie kann man auf Events reagieren oder Properties setzen? Die Komponenten sind nicht dafür ausgelegt.
     Entweder man baut setter für Properties und Event-Handling ein, also trennt GUI-Komponenten von Scout-Komponennten (analog Swing, SWT etc., siehe auch Abschnitt oben).
     Alternative könnte sein, man verwendet die Session-Events -> Für Offline-Komonenten eine Offline-Session injecten. Selection-Listener an Table würde in Wahrheit ein Listener an die Session anhängen.
     Setter würde es benötigen (z.B.: setSelectedRows würde model.selectedRows setzen, session.send und anschliessend renderSelectedRows aufrufen). Für Properties könnte man eventuell setter auch zur Laufzeit erzeugen, da es sie aktuell nicht gibt


Session.js vs. ClientSession.js.
- Dasselbe oder aufteilen? Auf dem Server gibt es heute JsonSession und JsonClientSession

Attach / Detach vs. new Scout.DesktopTable()
- Attach geht lange bei grossen Objekten (z.B. table mit 800 Rows)

Clientseitige Model-Handler wann erstellen? Von Gui-Komponenten trennen?
- Beispiel: Server schickt nodes und pro node table gleich mit, table darf aber noch nicht gerendert werden (wäre spezifisch für desktoptree)
  Aktuell wird einfach ein JsonDesktopTable erzeugt ohne gui, damit table events behandelt werden können.
- Soll die Erzeugung vom Server getriggert werden mittels create events? Aktuell wird die table einfach mit den nodes mitgeschickt

Datenübertragung
- Wenn keine Elemente vorhanden, leere Liste oder das Element nicht schicken? Keine undef Prüfung mit JS vs. weniger Daten-Übertragung
  -> [09.05.2014, awe, cgu]: Element nicht schicken
- Dasselbe gilt für Properties, welche den "Default"-Wert haben. z.B: maximizedEnabled ist zu 99% auf false bei Dialogen, muss das übertragen werden?
  Wir könnten initial auch eine Map mit Default-Props schicken und dann die einzelnen Props nur, falls sie nicht default sind. Ob man aber so viel spart dabei?
- Wie soll der Wert eines Properties gelöscht werden?
  -> [09.05.2014, awe, cgu]: Wir schicken einen Empty-String, auf dem Client kann dann mittels !value darauf geprüft werden.
- Wenn das GUI mit einem Wert kommt (z.B. selected=true bei CheckBox), dann muss der Server nicht mit selected=true darauf antworten.
  -> Der Property-Change Event vom Modell muss ignoriert werden -> PropertyChangeFilter bzw. Table oder TreeEventFilter
- Wenn ein neues Objekt an den Client geschickt werden soll und an diesem Objekt während dem Server-Cycle noch Änderungen vorgenommen werden, dann sind eigentlich die ersten Informationen obsolet. Wie wollen wir damit umgehen?
  Beispiel: Form wird dem Desktop hinzugefügt bewirkt ein toJson. Danach werden die Felder verändert.

Naming
- Events und Properties sollten wie im Modell benannt werden. Z.B: beim Menu: "text" statt "label", weil es IMenu.getText(); heisst
  Offen: Naming im CSS nachziehen?

Protokoll
- Jetzt schicken Client und Server events, sollte man das eventuell unterscheiden? Client->actions, Server->events? Ist nur ein Naming-Ding

RendererRegistry
- Die Objekte werden bei Bedarf erstellt. Der Client erhält die Notifikation mittels create event, oder über die initialisierung des Parent (toJson)
  - Offene Frage: Was passiert, wenn das Objekt im toJson bereits initialisiert wurde und erneut geschickt wird? Zur Zeit wird das Objekt auf dem Client neu erstellt. -> Leak?
- Dies führt zu einer inkrementellen Erstellung des Modells auf dem Client.
- Wann sollen die Objekte aufgeräumt werden? Bei From passiert es zur Zeit beim Close, jedoch nicht rekursiv -> Felder bleiben bestehen -> Leak

Auftrennung DesktopTree/DesktopTable
- Da es im Modell TableField und TreeField gibt, sollten wir die Tree bzw. Tabellen-Logik von der Desktop-Logik trennen. Ansonsten müssten wir die Anzeige-Logik duplizieren
- Chart, Graph, Map etc gehen zur Zeit fix auf DesktopTable, vorläufig vermutlich ok wenn diese Dinge nur in der Outline angezeigt werden können.
  Wünschenswert für die Zukunft wäre es, wenn diese Komponenten unabhängig von der Outline verwendet werden könnten, eigentlich sogar unabhängig von einer Tabelle.

JsHint
- Wir verwenden kein unused, weil sonst alle ungenützten Parameter auch angezeigt würden, was man leider nicht abstellen kann.

Javascript-Event-Handling
- Event-Listener müssen zwingend wieder entfernt werden (aktuell ein Problem im Menu.js)
- Sollten wir für globale Events (z.B. ('*') bei Menu.js) Namespaces verwenden, damit wir anderen nicht reinfunken (Portlets)?

Scout/Model-Anpassungen
- Feld-Validierungen
  Ziel: Validierungen und Formatierungen möglichst mittels Javascript machen
  - Pro Feld Pattern/Regex und Error-Meldung?
  - Möglichkeit für custom Javascript Validator/Formatter?
- Tabellen-Sortierung / Filterung soll ins JS
  Paging-Unterstützung andenken
- Unterstützung für Graph / Map / Chart auf Pages
  Was soll alles im Modell konfiguriert werden können?
- ViewButtons eigentlich nicht nötig, Modell ist auf dem Desktop vorhanden
- Editierbare-Tabellen
  Felder wären im JS bekannt, Tabelle hat aber execPrepare, execCompleteEdit etc.
  Dynamische Cell-Editierbarkeit müsste umbedingt umgebaut werden. Zur Zeit im prepare isCellEditable (execIsEditable) aufgerufen, also zum Zeitpunkt der Darstellung.
  Die Editierbarkeit darf nicht so berechnet werden, sondern muss über einen setter steuerbar sein, damit man 1. Veränderung der Editierbarkeit anzeigen kann und 2. vor dem Klicken schon weiss, ob man überhaupt ein Feld erzeugen muss
  Dies würde auch der aktuellen Mobile-Lösung zu gute kommen, welche dynamische Editierbarkeit zur Zeit nicht unterstützt, weil prepareEdit null zurückliefert falls Spalte zwar editierbar, aber Feld nicht -> Es müsste jederzeit ein Feld erzeugt werden können, egal ob aktuell enabled oder nicht.
- Filter bei Tree / Table (ITreeNodeFilter, ITableRowFilter) könnten auch vom JS übernommen werden
- Tabellen-Organisation soll neu ein eigenes GUI-Element sein (kein Standard-Form)
- Dynamische Outlines (Add/Remove)
- IDateColumn / ITimeColumn und ev. Felder müssen das Pattern zurückgeben können, analog INumberValueContainer
- Wie wollen wir mit den internen Tabellen bei NodePages umgehen? siehe auch FIXME in JsonDesktopTree -> vermutlich konfigurierbar machen auf nodepage
- Handling / Caching der Detail-Forms bei Pages sollte von Scout unterstützt werden (Bei activate Öffnen des Forms falls noch nicht gemacht, bei Dispose schliessen). Das Pattern ist immer dasselbe.

Scout-Pattern / Namespacing
- Scout verwendet genau einen Namespace namens scout
- Es gibt keine weitere Gruppierung mittels JS-Objekten (scout.abc.xy). Jede weitere Verschachtelung ist ein Objekt-Zugriff -> Performance-Impact
- Scout-Namespace wird mittels IIF (Immediate Invocation Function) erzeugt
- Die internen Objekte/Komponenten (Session, Menu, etc) werden innerhalb dieser IIF definiert
- Vorteil des IIF:
  - Die Scout-Komponenten müssen nicht mittels Scout.Komponente referenziert werden
  - API gegen aussen muss explizit definiert werden (die Komponenten müssen explizit freigegeben werden): scout.Menu = Menu;
- Scout ist ein Singleton, es gibt einmal window.scout
- Das Pattern könnte sich noch ändern, abhängig von Portlets und Erweiterbarkeit (siehe unten)

Session-Handling
- JsonSession beinhaltet zustand des Scout-Clients (welche Forms offen sind etc.)
- JsonSession muss pro div sein -> sessionPartId
- sessionPartId besteht aus tabId und divId
- HttpSession enthält sessionPartIds
- tabId darf nicht beim Neuladen der Seite bzw. beim Vor/Zurück neu erstellt werden, sonst wird jedesmal eine neue JsonSession erzeugt
- tabId muss darum in die Url geschrieben werden (?t=123)
- Tomcat unterstützt Cookie-Persistenz (mittels maxAge) -> Cookie wird nach dem Schliessen des Browsers NICHT gelöscht
- Damit diese Persistenz genutzt werden kann, muss tabId dieselbe sein wie beim vorherigen Besuch
- Benutzer kann entweder tabId selber eingeben (mühsam)
- Oder Scout fügt automatisch die letzte tabId hinzu
- Möglichkeiten:
  - tabId ist eine Laufnummer, wenn die tabId fehlt wird automatisch tabId = 0 hinzugefügt. Laufnummer kann im html 5 cache oder in der http session gehalten werden
  - tabId wird im html 5 cache gespeichert, wenn die tabId fehlt wird die (letzte) tabId aus dem html 5 cache geholt

Portlets
- Javascript und CSS müssen abgegrenzt werden
- Die Elemente dürfen nicht über #Element im CSS referenziert werden, da es #Element pro scout-div geben kann
  -> nur Klassen verwenden (.element)
- Sobald es mehrere Divs auf der Seite gibt, darf das CSS die Objekte nur innerhalb eines divs selektieren, also anstatt .table muss es #divId.table heissen
- Dieses Hinzufügen der divId kann vom Server übernommen werden. Client muss dem Server mitteilen, wieviele Divs es gibt.
- Falls es nur ein Div hat, ist diese Prozessierung nicht nötig. Vorteil: Selektion ist schneller
- Müssen / Wollen wir unterstützen, dass unterschiedliche Scout-Divs unterschiedliche Scout-Komponenten verwenden?
  Falls ja, muss entweder JS bei der Erstellung der Komponenten divId berücksichtigen.
  Oder pro (unterschiedlichem) scout div machen wir new Scout() anstatt ein Singleton (siehe scout-pattern.js)

Erweiterbarkeit
- Es muss möglich sein, Komponenten austauschen zu könnnen
- Dafür braucht eine Komponenten-Factory (analog FormFieldFactory)
- Pattern muss Registrierung von eigenen Komponenten ermöglichen -> scout.registerComponent();
- Wie gehen wir mit custom CSS um? Css erweiterbar machen mittels z.B. @extends? Build-Umgebung für Css / JS sollte den Projekten zur Verfügung gestellt werden
  Custom css nötig für eigene Komponenten + für eigenes Styling (Corporate Design)
- Wenn Projekt eine eigene JS-Library verwenden möchte, kann es die im Script-Tag einfügen -> Durch Namespacing grenzt sich Scout ab -> keine Konflikte
- Wie kann das Projekte eine bestehende Komponente erweitern / patchen?
  Komponente registrieren -> ok
  Komponente erweitern (extends) -> unklar. Nur via Build-Prozess? Oder genügt es, alle Scout-Komponenten öffentlich zu machen (scout.Table = Table)? Dann könnte man "JS-Vererbung" verwenden

Mobile
- Separates CSS und Javascript für mobile? Basierend auf scout.css?
  - Vorteile:
    - Man muss mobile Komponentent nicht mit eigenen CSS-Klassen bestücken (z.B. braucht es table-row-mobile nicht)
    - man kann CSS / JS für nicht verwendete Komponenten weglassen
    -> scout.js sowies scout-mobile.js sind so schlank wie möglich
  Damit wir den Source-Code nicht duplizieren müssen, sollten wir versuchen, unsere Widgets möglichst flexibel zu machen, also dass einzelne Komponenten ausgetauscht oder komplett weggelassen werden können.
  Z.B: Footer/Header bei der Tabelle oder Keystroke-Handling. Diese Komponenten können wir dann fürs scout-mobile.js einfach weglassen.
- Eventuell css eigenschaften mittels @Override verändern, damit das mobile css nicht unnötig aufgeblasen wird?
- Damit die mobilen CSS und JS-Dateien geladen werden, gibt es auch ein index-mobile.html. Dieses Html wird zurückgegeben, wenn es ein mobiler Browser ist und man auf / verbindet.
  Man kann aber auch direkt auf die mobile Version wechseln, indem man direkt /index-mobile.html ansteuert.
- Auf der Session.js gibt es ein UserAgent-Objekt (analog zur ClientSession auf dem Server), dort steht der deviceType drin.
  Das index-mobile.html initialisiert den UserAgent mit dem DeviceType „Mobile“. Bei einem Tablet sollte an dieser Stelle mit Tablet initialisiert werden, es gibt KEIN index-tablet.html.
  Wir erhoffen uns damit, dass wir dann live (responsive) zwischen mobile und tablet wechseln können.
- Template-Mechanismus für Tables? Damit man pro Table das Layout selber vorgeben kann (z.B. Datumsspalte rechts oben)
- User-Feedback:
  Browser haben ein 300ms delay, siehe auch index-mobile.html
  Touch-Feedback kann man mittels den Pseudeselektor :active steuern. MouseDown kommt nicht bei TouchStart, da man nicht weiss, ob TouchStart zu einem Tab oder Scroll führt

Styling / Farben
- Wie wollen wir mit Custom Styling umgehen? Soll es die Properties setBackgroundColor / setFont etc weiterhin geben?
  Gedanken: Styling könnte komplett im CSS gemacht werden. Beispiele:
    .text-field: background-color: blue;
    .person-form > text-field: background-color: blue; -> Möglichkeit für eigene Klassen muss gegeben sein
    .classId: background-color: blue -> scout classId als css class hinzufügen, eindeutig stylebar
  Problem dabei: Dynamisches Anpassen des Styles ist nicht möglich. Beispiel: Zelle (3,4) in einer Tabelle soll rot werden, wenn Zelle (2,3) leer ist.
  Könnte man lösen, indem jedes Scout-Objekt ein Property css-styles bekommt, oder weiterhin über setBackgroundColor.
  Problem dabei: Die verwendeten Farben müssen zum aktuellen Scout-CSS passen.
  -> Das CRM darf keine fixen Farben verwenden, weil wenn das Projekt ein eigenes CSS hat diese Farben nicht mehr passen.
  Besser wäre es vermutlich, eine Farb-Palette zu definieren. Das CRM könnte dann Konstanten aus dieser Palette verwenden.


Erweiterbarkeit, Dependencies und weitere js Resourcen in externen Bundles
Beispiel:
<code>
  ScoutTextField.js
#package/namespace "Scout"
#require ScoutFormField.js



scout.js
(function(scout, $, undefined) {
  #include("Scout")
}(window.scout = window.scout || {}, jQuery));


gothaer.js
#require scout.js
(function(scout, $, undefined) {
  #include("Gothaer")
}(window.scout = window.scout || {}, jQuery));
</code>
