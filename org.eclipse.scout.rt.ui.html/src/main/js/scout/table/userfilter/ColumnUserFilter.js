scout.ColumnUserFilter = function() {
  scout.ColumnUserFilter.parent.call(this);
  this.filterType = 'column';

  /**
   * array of (normalized) key, text composite
   */
  this.availableValues = [];

  /**
   * array of (normalized) keys
   */
  this.selectedValues = [];
};
scout.inherits(scout.ColumnUserFilter, scout.TableUserFilter);

scout.ColumnUserFilter.prototype.calculateCube = function() {
  var containsSelectedValue, reorderAxis,
    group = -1;

  if (this.column.type === 'date') {
    if (this.column.hasDate) {
      // Default grouping for date columns is year
      group = scout.ChartTableControlMatrix.DateGroup.YEAR;
    }
    else {
      // No grouping for time columns
      group = scout.ChartTableControlMatrix.DateGroup.NONE;
    }
  }
  this.matrix = new scout.ChartTableControlMatrix(this.table, this.session),
  this.xAxis = this.matrix.addAxis(this.column, group);
  this.matrix.calculateCube();

  this.selectedValues.forEach(function(selectedValue) {
    containsSelectedValue = false;
    if (this.column.type === 'text') {
      selectedValue = this.xAxis.norm(selectedValue);
    }
    this.xAxis.some(function(key) {
      if (key === selectedValue) {
        containsSelectedValue = true;
        return true;
      }
    }, this);

    if (!containsSelectedValue) {
      this.xAxis.push(selectedValue);
      reorderAxis = true;
    }
  }, this);

  if (reorderAxis) {
    this.xAxis.reorder();
  }

  this.availableValues = [];
  this.xAxis.forEach(function(key) {
    var text = this.xAxis.format(key);
    // In case of text columns, the normalized key generated by the matrix is not deterministic, it depends on the table data
    // -> use the text.
    // In the other cases it is possible to use the normalized key which has the advantage that it is locale independent
    if (this.column.type === 'text') {
      key = text;
    }
    this.availableValues.push({key: key, text: text});
  }, this);
};

scout.ColumnUserFilter.prototype.createAddFilterEventData = function() {
  var data = scout.ColumnUserFilter.parent.prototype.createAddFilterEventData.call(this);
  return $.extend(data, {
    columnId: this.column.id,
    selectedValues: this.selectedValues
  });
};

scout.ColumnUserFilter.prototype.createRemoveFilterEventData = function() {
  var data = scout.ColumnUserFilter.parent.prototype.createRemoveFilterEventData.call(this);
  return $.extend(data, {
    columnId: this.column.id
  });
};

scout.ColumnUserFilter.prototype.createLabel = function() {
  return this.column.text || '';
};

scout.ColumnUserFilter.prototype.createKey = function() {
  return this.column.id;
};

scout.ColumnUserFilter.prototype.accept = function($row) {
  if (!this.xAxis) {
    // Lazy calculation. It is not possible on init, because the table is not rendered yet.
    this.calculateCube();
  }
  var row = $row.data('row'),
    key = this.column.cellValueForGrouping(row),
    normKey = this.xAxis.norm(key);

  if (this.column.type === 'text') {
    normKey = this.xAxis.format(normKey);
  }
  return (this.selectedValues.indexOf(normKey) > -1);
};
