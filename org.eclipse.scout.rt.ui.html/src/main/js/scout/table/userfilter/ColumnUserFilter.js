/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ColumnUserFilter = function() {
  scout.ColumnUserFilter.parent.call(this);
  this.filterType = scout.ColumnUserFilter.Type;

  /**
   * array of (normalized) key, text composite
   */
  this.availableValues = [];

  /**
   * array of (normalized) keys
   */
  this.selectedValues = [];

  // FIXME AWE: split this class into Text-, Number- and Date-ColumnUserFilter, use Range object
  this.freeText;
  this.numberFrom;
  this.numberTo;
  this.dateFrom;
  this.dateTo;
};
scout.inherits(scout.ColumnUserFilter, scout.TableUserFilter);

scout.ColumnUserFilter.Type = 'column';


/**
 * @override TableUserFilter.js
 */
scout.ColumnUserFilter.prototype._init = function(model) {
  scout.ColumnUserFilter.parent.prototype._init.call(this, model);
  if (this.column.type === 'date') {
    this.dateFrom = scout.dates.parseJsonDate(this.dateFrom);
    this.dateTo = scout.dates.parseJsonDate(this.dateTo);
  }
};

scout.ColumnUserFilter.prototype.calculate = function() {
  var containsSelectedValue, reorderAxis,
    group = -1;

  if (this.column.type === 'date') {
    if (this.column.hasDate) {
      // Default grouping for date columns is year
      group = scout.TableCube.DateGroup.YEAR;
    } else {
      // No grouping for time columns
      group = scout.TableCube.DateGroup.NONE;
    }
  }
  this.matrix = new scout.TableCube(this.table, this.session);
  this.matrix.addData(this.column, scout.TableCube.NumberGroup.COUNT);
  this.xAxis = this.matrix.addAxis(this.column, group);
  var cube = this.matrix.calculate();

  this.selectedValues.forEach(function(selectedValue) {
    containsSelectedValue = false;
    if (this._useTextInsteadOfNormValue(selectedValue)) {
      // selected value was not normalized -> normalize
      selectedValue = this.xAxis.norm(selectedValue);
    }
    this.xAxis.some(function(key) {
      if (key === selectedValue) {
        containsSelectedValue = true;
        return true;
      }
    }, this);

    if (!containsSelectedValue) {
      this.xAxis.push(selectedValue);
      reorderAxis = true;
    }
  }, this);

  if (reorderAxis) {
    this.xAxis.reorder();
  }

  var text, displayKey, cubeValue;
  this.availableValues = [];
  this.xAxis.forEach(function(key) {
    displayKey = key;
    text = this.xAxis.format(key);
    if (this._useTextInsteadOfNormValue(key)) {
      displayKey = text;
    }
    cubeValue = cube.getValue([key]);
    this.availableValues.push({
      key: displayKey,
      text: text,
      count: cubeValue ? cubeValue[0] : 0
    });
  }, this);
};

/**
 * In case of text columns, the normalized key generated by the matrix is not deterministic, it depends on the table data
 * -> use the text.
 * In the other cases it is possible to use the normalized key which has the advantage that it is locale independent
 */
scout.ColumnUserFilter.prototype._useTextInsteadOfNormValue = function(value) {
  if (value === null) {
    // null is valid, if for text columns. We do not want to store -empty-
    return false;
  }
  return this.column.type === 'text';
};

scout.ColumnUserFilter.prototype.createAddFilterEventData = function() {
  var data = scout.ColumnUserFilter.parent.prototype.createAddFilterEventData.call(this);
  data = $.extend(data, {
    columnId: this.column.id,
    selectedValues: this.selectedValues
  });

  if (this.column.type === 'text') {
    data.freeText = this.freeText;
  } else if (this.column.type === 'number') {
    data.numberFrom = this.numberFrom;
    data.numberTo = this.numberTo;
  } else if (this.column.type === 'date') {
    data.dateFrom = scout.dates.toJsonDate(this.dateFrom);
    data.dateTo = scout.dates.toJsonDate(this.dateTo);
  }

  return data;
};

scout.ColumnUserFilter.prototype.createRemoveFilterEventData = function() {
  var data = scout.ColumnUserFilter.parent.prototype.createRemoveFilterEventData.call(this);
  return $.extend(data, {
    columnId: this.column.id
  });
};

scout.ColumnUserFilter.prototype.createLabel = function() {
  return this.column.text || '';
};

scout.ColumnUserFilter.prototype.createKey = function() {
  return this.column.id;
};

scout.ColumnUserFilter.prototype.accept = function(row) {
  if (!this.xAxis) {
    // Lazy calculation. It is not possible on init, because the table is not rendered yet.
    this.calculate();
  }
  var acceptByTable = true, acceptByFields = true,
    key = this.column.cellValueForGrouping(row),
    normKey = this.xAxis.norm(key);

  if (this._useTextInsteadOfNormValue(normKey)) {
    normKey = this.xAxis.format(normKey);
  }

  if (this.tableFilterActive()) {
    acceptByTable = this.selectedValues.indexOf(normKey) > -1;
  }

  if (this.fieldsFilterActive()) {
    if (this.column.type === 'text') {
      // FIXME AWE (filter) use cellTextForTextFilter
      acceptByFields = normKey.toLowerCase().indexOf(this.freeText.toLowerCase()) > -1;
    } else if (this.column.type === 'number') {
      var
        hasFrom = scout.objects.isNumber(this.numberFrom),
        hasTo = scout.objects.isNumber(this.numberTo);
      if (hasFrom && hasTo) {
        acceptByFields = normKey >= this.numberFrom && normKey <= this.numberTo;
      } else if (hasFrom) {
        acceptByFields = normKey >= this.numberFrom;
      } else if (hasTo) {
        acceptByFields = normKey <= this.numberTo;
      }
    } else if (this.column.type === 'date') {
      var
        keyValue = key.valueOf(),
        fromValue = this.dateFrom ? this.dateFrom.valueOf() : null,
        toValue  = this.dateTo ? this.dateTo.valueOf() : null;
      if (fromValue && toValue) {
        acceptByFields = keyValue >= fromValue && keyValue <= toValue;
      } else if (fromValue) {
        acceptByFields = keyValue >= fromValue;
      } else if (toValue) {
        acceptByFields = keyValue <= toValue;
      }
    }
  }

  return acceptByTable && acceptByFields;
};

scout.ColumnUserFilter.prototype.updateFilterFields = function(event) {
  $.log.debug('(ColumnUserFilter#updateFilterFields) filterType=' + event.filterType + ' text=' + event.text);
  var from, to;
  if (event.filterType === 'text') {
    this.freeText = event.text.trim();
  } else if (event.filterType === 'number') {
    // FIXME AWE: (filter) discuss with C.GU... unser NumberField.js kann keinen value (numeric) liefern, richtig?
    // Das field sollte etwas wie getValue() haben das eine fixfertige number liefert anstatt der konvertierung hier
    this.numberFrom = this._toNumber(event.from),
    this.numberTo = this._toNumber(event.to);
  } else if (event.filterType === 'date') {
    this.dateFrom = event.from,
    this.dateTo = event.to;
  } else {
    throw new Error('unknown filter type');
  }
};

scout.ColumnUserFilter.prototype._toNumber = function(numberString) {
  if (!numberString) {
    return null;
  }
  // clean number string (only digits remain) // FIXME AWE (filter) improv. doesnt work for fractions, etc
  numberString = numberString.replace(/\D/g, '');

  var number = parseInt(numberString, 10);
  if (isNaN(number)) {
    return null;
  }

  return number;
};

scout.ColumnUserFilter.prototype.filterActive = function() {
  return this.tableFilterActive() || this.fieldsFilterActive();
};

scout.ColumnUserFilter.prototype.tableFilterActive = function() {
  return this.selectedValues.length > 0;
};

scout.ColumnUserFilter.prototype.fieldsFilterActive = function() {
  if (this.column.type === 'text') {
    return scout.strings.hasText(this.freeText);
  } else if (this.column.type === 'number') {
    return scout.objects.isNumber(this.numberFrom) || scout.objects.isNumber(this.numberTo);
  } else if (this.column.type === 'date') {
    return this.dateFrom || this.dateTo;
  }
};
