Aufteilung zwischen GUI-Elementen und Server / Model-Interaktion?
- z.B. Table schickt Server Event im Selektions-Code. Alternative wäre ein Listener, welcher auf Selektion hört und dort den Event schickt.
- Vorteil des Listeners: Saubere Trennung, Komponenten könnten einfacher ersetzt werden?
- Nachteil: Eventuell unnötiger Zusatzaufwand

Session.js vs. ClientSession.js.
- Dasselbe oder aufteilen? Auf dem Server gibt es heute JsonSession und JsonClientSession

Attach / Detach vs. new Scout.DesktopTable()
- Attach geht lange bei grossen Objekten (z.B. table mit 800 Rows)

Clientseitige Model-Handler wann erstellen? Von Gui-Komponenten trennen?
- Beispiel: Server schickt nodes und pro node table gleich mit, table darf aber noch nicht gerendert werden (wäre spezifisch für desktoptree)
  Aktuell wird einfach ein JsonDesktopTable erzeugt ohne gui, damit table events behandelt werden können.
- Soll die Erzeugung vom Server getriggert werden mittels create events? Aktuell wird die table einfach mit den nodes mitgeschickt

Datenübertragung
- Wenn keine Elemente vorhanden, leere Liste oder das Element nicht schicken? Keine undef Prüfung mit JS vs. weniger Daten-Übertragung
  -> [09.05.2014, awe, cgu]: Element nicht schicken
- Dasselbe gilt für Properties, welche den "Default"-Wert haben. z.B: maximizedEnabled ist zu 99% auf false bei Dialogen, muss das übertragen werden?
  Wir könnten initial auch eine Map mit Default-Props schicken und dann die einzelnen Props nur, falls sie nicht default sind. Ob man aber so viel spart dabei?
- Wie soll der Wert eines Properties gelöscht werden?
  -> [09.05.2014, awe, cgu]: Wir schicken einen Empty-String, auf dem Client kann dann mittels !value darauf geprüft werden.

Naming
- Events und Properties sollten wie im Modell benannt werden. Z.B: beim Menu: "text" statt "label", weil es IMenu.getText(); heisst
  Offen: Naming im CSS nachziehen?

Protokoll
- Jetzt schicken Client und Server events, sollte man das eventuell unterscheiden? Client->actions, Server->events? Ist nur ein Naming-Ding

Auftrennung DesktopTree/DesktopTable
- Da es im Modell TableField und TreeField gibt, sollten wir die Tree bzw. Tabellen-Logik von der Desktop-Logik trennen. Ansonsten müssten wir die Anzeige-Logik duplizieren
- Chart, Graph, Map etc gehen zur Zeit fix auf DesktopTable, vorläufig vermutlich ok wenn diese Dinge nur in der Outline angezeigt werden können.
  Wünschenswert für die Zukunft wäre es, wenn diese Komponenten unabhängig von der Outline verwendet werden könnten, eigentlich sogar unabhängig von einer Tabelle.

JsHint
- Wir verwenden kein unused, weil sonst alle ungenützten Parameter auch angezeigt würden, was man leider nicht abstellen kann.

Javascript-Event-Handling
- Event-Listener müssen zwingend wieder entfernt werden (aktuell ein Problem im Menu.js)
- Sollten wir für globale Events (z.B. ('*') bei Menu.js) Namespaces verwenden, damit wir anderen nicht reinfunken (Portlets)?

Scout/Model-Anpassungen
- Feld-Validierungen
  Ziel: Validierungen und Formatierungen möglichst mittels Javascript machen
  - Pro Feld Pattern/Regex und Error-Meldung?
  - Möglichkeit für custom Javascript Validator/Formatter?
- Tabellen-Sortierung / Filterung soll ins JS
  Paging-Unterstützung andenken
- Unterstützung für Graph / Map / Chart auf Pages
  Was soll alles im Modell konfiguriert werden können?
- ViewButtons eigentlich nicht nötig, Modell ist auf dem Desktop vorhanden
- Editierbare-Tabellen
  Felder wären im JS bekannt, Tabelle hat aber execPrepare, execCompleteEdit etc.
- Filter bei Tree / Table (ITreeNodeFilter, ITableRowFilter) könnten auch vom JS übernommen werden
- Tabellen-Organisation soll neu ein eigenes GUI-Element sein (kein Standard-Form)
- Dynamische Outlines (Add/Remove)
- IDateColumn / ITimeColumn und ev. Felder müssen das Pattern zurückgeben können, analog INumberValueContainer
- Wie wollen wir mit den internen Tabellen bei NodePages umgehen? siehe auch FIXME in JsonDesktopTree -> vermutlich konfigurierbar machen auf nodepage

Scout-Pattern / Namespacing
- Scout verwendet genau einen Namespace namens scout
- Es gibt keine weitere Gruppierung mittels JS-Objekten (scout.abc.xy). Jede weitere Verschachtelung ist ein Objekt-Zugriff -> Performance-Impact
- Scout-Namespace wird mittels IIF (Immediate Invocation Function) erzeugt
- Die internen Objekte/Komponenten (Session, Menu, etc) werden innerhalb dieser IIF definiert
- Vorteil des IIF:
  - Die Scout-Komponenten müssen nicht mittels Scout.Komponente referenziert werden
  - API gegen aussen muss explizit definiert werden (die Komponenten müssen explizit freigegeben werden): scout.Menu = Menu;
- Scout ist ein Singleton, es gibt einmal window.scout
- Das Pattern könnte sich noch ändern, abhängig von Portlets und Erweiterbarkeit (siehe unten)

Session-Handling
- JsonSession beinhaltet zustand des Scout-Clients (welche Forms offen sind etc.)
- JsonSession muss pro div sein -> sessionPartId
- sessionPartId besteht aus tabId und divId
- HttpSession enthält sessionPartIds
- tabId darf nicht beim Neuladen der Seite bzw. beim Vor/Zurück neu erstellt werden, sonst wird jedesmal eine neue JsonSession erzeugt
- tabId muss darum in die Url geschrieben werden (?t=123)
- Tomcat unterstützt Cookie-Persistenz (mittels maxAge) -> Cookie wird nach dem Schliessen des Browsers NICHT gelöscht
- Damit diese Persistenz genutzt werden kann, muss tabId dieselbe sein wie beim vorherigen Besuch
- Benutzer kann entweder tabId selber eingeben (mühsam)
- Oder Scout fügt automatisch die letzte tabId hinzu
- Möglichkeiten:
  - tabId ist eine Laufnummer, wenn die tabId fehlt wird automatisch tabId = 0 hinzugefügt. Laufnummer kann im html 5 cache oder in der http session gehalten werden
  - tabId wird im html 5 cache gespeichert, wenn die tabId fehlt wird die (letzte) tabId aus dem html 5 cache geholt

Portlets
- Javascript und CSS müssen abgegrenzt werden
- Die Elemente dürfen nicht über #Element im CSS referenziert werden, da es #Element pro scout-div geben kann
  -> nur Klassen verwenden (.element)
- Sobald es mehrere Divs auf der Seite gibt, darf das CSS die Objekte nur innerhalb eines divs selektieren, also anstatt .table muss es #divId.table heissen
- Dieses Hinzufügen der divId kann vom Server übernommen werden. Client muss dem Server mitteilen, wieviele Divs es gibt.
- Falls es nur ein Div hat, ist diese Prozessierung nicht nötig. Vorteil: Selektion ist schneller
- Müssen / Wollen wir unterstützen, dass unterschiedliche Scout-Divs unterschiedliche Scout-Komponenten verwenden?
  Falls ja, muss entweder JS bei der Erstellung der Komponenten divId berücksichtigen.
  Oder pro (unterschiedlichem) scout div machen wir new Scout() anstatt ein Singleton (siehe scout-pattern.js)

Erweiterbarkeit
- Es muss möglich sein, Komponenten austauschen zu könnnen
- Dafür braucht eine Komponenten-Factory (analog FormFieldFactory)
- Pattern muss Registrierung von eigenen Komponenten ermöglichen -> scout.registerComponent();
- Wie gehen wir mit custom CSS um? Css erweiterbar machen mittels z.B. @extends? Build-Umgebung für Css / JS sollte den Projekten zur Verfügung gestellt werden
  Custom css nötig für eigene Komponenten + für eigenes Styling (Corporate Design)
- Wenn Projekt eine eigene JS-Library verwenden möchte, kann es die im Script-Tag einfügen -> Durch Namespacing grenzt sich Scout ab -> keine Konflikte
- Wie kann das Projekte eine bestehende Komponente erweitern / patchen?
  Komponente registrieren -> ok
  Komponente erweitern (extends) -> unklar. Nur via Build-Prozess? Oder genügt es, alle Scout-Komponenten öffentlich zu machen (scout.Table = Table)? Dann könnte man "JS-Vererbung" verwenden

Mobile
- Separates CSS und Javascript für mobile? Basierend auf scout.css?
  - Vorteile:
    - Man muss mobile Komponentent nicht mit eigenen CSS-Klassen bestücken (z.B. braucht es table-row-mobile nicht)
    - man kann CSS / JS für nicht verwendete Komponenten weglassen
    -> scout.js sowies scout-mobile.js sind so schlank wie möglich
  Damit wir den Source-Code nicht duplizieren müssen, sollten wir versuchen, unsere Widgets möglichst flexibel zu machen, also dass einzelne Komponenten ausgetauscht oder komplett weggelassen werden können.
  Z.B: Footer/Header bei der Tabelle oder Keystroke-Handling. Diese Komponenten können wir dann fürs scout-mobile.js einfach weglassen.
- Eventuell css eigenschaften mittels @Override verändern, damit das mobile css nicht unnötig aufgeblasen wird?
- Damit die mobilen CSS und JS-Dateien geladen werden, gibt es auch ein index-mobile.html. Dieses Html wird zurückgegeben, wenn es ein mobiler Browser ist und man auf / verbindet.
  Man kann aber auch direkt auf die mobile Version wechseln, indem man direkt /index-mobile.html ansteuert.
- Auf der Session.js gibt es ein UserAgent-Objekt (analog zur ClientSession auf dem Server), dort steht der deviceType drin.
  Das index-mobile.html initialisiert den UserAgent mit dem DeviceType „Mobile“. Bei einem Tablet sollte an dieser Stelle mit Tablet initialisiert werden, es gibt KEIN index-tablet.html.
  Wir erhoffen uns damit, dass wir dann live (responsive) zwischen mobile und tablet wechseln können.
- Template-Mechanismus für Tables? Damit man pro Table das Layout selber vorgeben kann (z.B. Datumsspalte rechts oben)

Plugin-Struktur
- Aufteilung html / json ok, aber zur Zeit ist es nicht optimal.
  - pom.xml von ui.html generiert files für ui.json? Muss das WebContent im ui.json drin sein?
  - ScriptProcessor ist im Html-Plugin drin, processing wird aber im json plugin gemacht
  -> eigentlich sind beide voneinander abhängig, was ein bisschen komisch ist.


Styling / Farben
- Wie wollen wir mit Custom Styling umgehen? Soll es die Properties setBackgroundColor / setFont etc weiterhin geben?
  Gedanken: Styling könnte komplett im CSS gemacht werden. Beispiele:
    .text-field: background-color: blue;
    .person-form > text-field: background-color: blue; -> Möglichkeit für eigene Klassen muss gegeben sein
    .classId: background-color: blue -> scout classId als css class hinzufügen, eindeutig stylebar
  Problem dabei: Dynamisches Anpassen des Styles ist nicht möglich. Beispiel: Zelle (3,4) in einer Tabelle soll rot werden, wenn Zelle (2,3) leer ist.
  Könnte man lösen, indem jedes Scout-Objekt ein Property css-styles bekommt, oder weiterhin über setBackgroundColor.
  Problem dabei: Die verwendeten Farben müssen zum aktuellen Scout-CSS passen.
  -> Das CRM darf keine fixen Farben verwenden, weil wenn das Projekt ein eigenes CSS hat diese Farben nicht mehr passen.
  Besser wäre es vermutlich, eine Farb-Palette zu definieren. Das CRM könnte dann Konstanten aus dieser Palette verwenden.
