Aufteilung zwischen GUI-Elementen und Server / Model-Interaktion?
- z.B. Table schickt Server Event im Selektions-Code. Alternative wäre ein Listener, welcher auf Selektion hört und dort den Event schickt.
- Vorteil des Listeners: Saubere Trennung, Komponenten könnten einfacher ersetzt werden?
- Nachteil: Eventuell unnötiger Zusatzaufwand

Session.js vs. ClientSession.js.
- Dasselbe oder aufteilen? Auf dem Server gibt es heute JsonSession und JsonClientSession

Attach / Detach vs. new Scout.DesktopTable()
- Attach geht lange bei grossen Objekten (z.B. table mit 800 Rows)

Clientseitige Model-Handler wann erstellen? Von Gui-Komponenten trennen?
- Beispiel: Server schickt nodes und pro node table gleich mit, table darf aber noch nicht gerendert werden (wäre spezifisch für desktoptree)
  Aktuell wird einfach ein JsonDesktopTable erzeugt ohne gui, damit table events behandelt werden können.
- Soll die Erzeugung vom Server getriggert werden mittels create events? Aktuell wird die table einfach mit den nodes mitgeschickt

Datenübertragung
- Wenn keine Elemente vorhanden, leere Liste oder das Element nicht schicken? Keine undef Prüfung mit JS vs. weniger Daten-Übertragung

Naming
- Events und Properties sollten wie im Modell benannt werden. Z.B: beim Menu: "text" statt "label", weil es IMenu.getText(); heisst
  Offen: Naming im CSS nachziehen?

JsHint
- Wir verwenden kein unused, weil sonst alle ungenützten Parameter auch angezeigt würden, was man leider nicht abstellen kann.

Javascript-Event-Handling
- Event-Listener müssen zwingend wieder entfernt werden (aktuell ein Problem im Menu.js)
- Sollten wir für globale Events (z.B. ('*') bei Menu.js) Namespaces verwenden, damit wir anderen nicht reinfunken (Portlets)?

Scout/Model-Anpassungen
- Feld-Validierungen
  Ziel: Validierungen und Formatierungen möglichst mittels Javascript machen
  - Pro Feld Pattern/Regex und Error-Meldung?
  - Möglichkeit für custom Javascript Validator/Formatter?
- Tabellen-Sortierung / Filterung soll ins JS
  Paging-Unterstützung andenken
- Unterstützung für Graph / Map / Chart auf Pages
  Was soll alles im Modell konfiguriert werden können?
- ViewButtons eigentlich nicht nötig, Modell ist auf dem Desktop vorhanden
- Editierbare-Tabellen
  Felder wären im JS bekannt, Tabelle hat aber execPrepare, execCompleteEdit etc.
- Filter bei Tree / Table (ITreeNodeFilter, ITableRowFilter) könnten auch vom JS übernommen werden
- Tabellen-Organisation soll neu ein eigenes GUI-Element sein (kein Standard-Form)
- Dynamische Outlines (Add/Remove)

Scout-Pattern / Namespacing
- Scout verwendet genau einen Namespace namens scout
- Es gibt keine weitere Gruppierung mittels JS-Objekten (scout.abc.xy). Jede weitere Verschachtelung ist ein Objekt-Zugriff -> Performance-Impact
- Scout-Namespace wird mittels IIF (Immediate Invocation Function) erzeugt
- Die internen Objekte/Komponenten (Session, Menu, etc) werden innerhalb dieser IIF definiert
- Vorteil des IIF:
  - Die Scout-Komponenten müssen nicht mittels Scout.Komponente referenziert werden
  - API gegen aussen muss explizit definiert werden (die Komponenten müssen explizit freigegeben werden): scout.Menu = Menu;
- Scout ist ein Singleton, es gibt einmal window.scout
- Das Pattern könnte sich noch ändern, abhängig von Portlets und Erweiterbarkeit (siehe unten)

Session-Handling
- JsonSession beinhaltet zustand des Scout-Clients (welche Forms offen sind etc.)
- JsonSession muss pro div sein -> sessionPartId
- sessionPartId besteht aus tabId und divId
- HttpSession enthält sessionPartIds
- tabId darf nicht beim Neuladen der Seite bzw. beim Vor/Zurück neu erstellt werden, sonst wird jedesmal eine neue JsonSession erzeugt
- tabId muss darum in die Url geschrieben werden (?t=123)
- Tomcat unterstützt Cookie-Persistenz (mittels maxAge) -> Cookie wird nach dem Schliessen des Browsers NICHT gelöscht
- Damit diese Persistenz genutzt werden kann, muss tabId dieselbe sein wie beim vorherigen Besuch
- Benutzer kann entweder tabId selber eingeben (mühsam)
- Oder Scout fügt automatisch die letzte tabId hinzu
- Möglichkeiten:
  - tabId ist eine Laufnummer, wenn die tabId fehlt wird automatisch tabId = 0 hinzugefügt. Laufnummer kann im html 5 cache oder in der http session gehalten werden
  - tabId wird im html 5 cache gespeichert, wenn die tabId fehlt wird die (letzte) tabId aus dem html 5 cache geholt

Portlets
- Javascript und CSS müssen abgegrenzt werden
- Die Elemente dürfen nicht über #Element im CSS referenziert werden, da es #Element pro scout-div geben kann
  -> nur Klassen verwenden (.element)
- Sobald es mehrere Divs auf der Seite gibt, darf das CSS die Objekte nur innerhalb eines divs selektieren, also anstatt .table muss es #divId.table heissen
- Dieses Hinzufügen der divId kann vom Server übernommen werden. Client muss dem Server mitteilen, wieviele Divs es gibt.
- Falls es nur ein Div hat, ist diese Prozessierung nicht nötig. Vorteil: Selektion ist schneller
- Müssen / Wollen wir unterstützen, dass unterschiedliche Scout-Divs unterschiedliche Scout-Komponenten verwenden?
  Falls ja, muss entweder JS bei der Erstellung der Komponenten divId berücksichtigen.
  Oder pro (unterschiedlichem) scout div machen wir new Scout() anstatt ein Singleton (siehe scout-pattern.js)

Erweiterbarkeit
- Es muss möglich sein, Komponenten austauschen zu könnnen
- Dafür braucht eine Komponenten-Factory (analog FormFieldFactory)
- Pattern muss Registrierung von eigenen Komponenten ermöglichen -> scout.registerComponent();
- Wie gehen wir mit custom CSS um? Css erweiterbar machen mittels z.B. @extends? Build-Umgebung für Css / JS sollte den Projekten zur Verfügung gestellt werden
  Custom css nötig für eigene Komponenten + für eigenes Styling (Corporate Design)
- Wenn Projekt eine eigene JS-Library verwenden möchte, kann es die im Script-Tag einfügen -> Durch Namespacing grenzt sich Scout ab -> keine Konflikte
- Wie kann das Projekte eine bestehende Komponente erweitern / patchen?
  Komponente registrieren -> ok
  Komponente erweitern (extends) -> unklar. Nur via Build-Prozess? Oder genügt es, alle Scout-Komponenten öffentlich zu machen (scout.Table = Table)? Dann könnte man "JS-Vererbung" verwenden
